<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.2.5">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Matthew Turk">

  
  
  
    
  
  <meta name="description" content="The first post in a deep dive into yt frontends, chunking, and why and how they might be refactored.">

  
  <link rel="alternate" hreflang="en-us" href="https://matthewturk.github.io/post/refactoring-yt-frontends-part1/">

  


  

  

  

  

  

  

  
  
  
  <meta name="theme-color" content="#EF525B">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.331f53d055a276ccbdada146254dc48b.css">

  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-141183895-1', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://matthewturk.github.io/post/refactoring-yt-frontends-part1/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@powersoffour">
  <meta property="twitter:creator" content="@powersoffour">
  
  <meta property="og:site_name" content="mjt">
  <meta property="og:url" content="https://matthewturk.github.io/post/refactoring-yt-frontends-part1/">
  <meta property="og:title" content="Refactoring yt Frontends - Part 1 | mjt">
  <meta property="og:description" content="The first post in a deep dive into yt frontends, chunking, and why and how they might be refactored."><meta property="og:image" content="https://matthewturk.github.io/img/icon-192.png">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-05-31T17:06:12-05:00">
  
  <meta property="article:modified_time" content="2019-06-02T16:11:11-05:00">
  

  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
  window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "#EF525B",
          "text": "#EAE7D6"
        },
        "button": {
          "background": "#EAE7D6",
          "text": "#EF525B"
        }
      },
      "theme": "classic",
      "content": {
        "message": "This website uses cookies to ensure you get the best experience on our website.",
        "dismiss": "Got it!",
        "link": "Learn more",
        "href": "https://cookies.insites.com"
      }
    })});
</script>


  

  <title>Refactoring yt Frontends - Part 1 | mjt</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >
  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">mjt</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
            
            <span>Posts</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#projects">
            
            <span>Projects</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#courses">
            
            <span>Courses</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#talks">
            
            <span>Talks</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#publications">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#contact">
            
            <span>Contact</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
            
          
        

        <li class="nav-item">
          <a class="nav-link" href="https://data-exp-lab.github.io/" target="_blank" rel="noopener">
            
            <span>Research Group</span>
            
          </a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        

      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1 itemprop="name">Refactoring yt Frontends - Part 1</h1>

  

  
    



<meta content="2019-05-31 17:06:12 -0500 CDT" itemprop="datePublished">
<meta content="2019-06-02 16:11:11 -0500 CDT" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
          Last updated on
      
    
    <time>Jun 2, 2019</time>
  </span>
  

  

  

  
  

  
  

  
    

  

</div>

    








  








<div class="btn-links mb-3">
  
  








  









  
  <a class="btn btn-outline-primary my-1 mr-1" href="/project/yt/">
    Project
  </a>
  











</div>


  
</div>



  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      <p>In the still-in-development version of yt (4.0), the way that particles are handled has been redesigned from the ground up.</p>
<p>The current version of yt (3.x) utilizes an octree-based approach for meshing the particles, although not for indexing them &ndash; which presents some problems when doing subsets of particles, as well as when doing visualizations that rely on an implicit meshing.  The main result is that, in general, particle visualizations in yt 3.x aren't that great, and are underresolved.</p>
<p>In yt 4.0, the particle system has been reimplemented to use EWAH bitmap indices (for more info, see Daniel Lemire's <a href="https://github.com/lemire/EWAHBoolArray">EWAHBoolArray</a> repository) to track which &ldquo;regions&rdquo; of files correspond to particular spatial regions, as designated by indices in a space-filling curve.  Things are now orders of magnitude faster to load, to subset, and to visualize &ndash; and the memory overhead is so much lower!</p>
<p>This work was led by Nathan Goldbaum and Meagan Lang, with crucial contributions from the rest of the yt community, including feedback and bugfixes from Bili Dong and Cameron Hummels.</p>
<p>Recently, I've been exploring using a different array backend in yt, right now focusing on <a href="https://dask.pydata.org/">dask</a>.  While yt does lots of MPI-parallel operations, much of what we do with these has to be hand-programmed &ndash; so when you implement a new <code>DerivedQuantity</code> (i.e., stuff like calling <code>min</code> on a data object) you have to jump through a few hoops related to intermediate values and the like.  Plus, dask seems to be everywhere, and so if we exported to dask arrays or somehow interoperated better with it, we'd be able to interoperate with lots of the rest of the ecosystem more easily.</p>
<p>Unfortunately, there's a bit of an impedance mismatch which &hellip; has made this more difficult than I'd like.</p>
<h2 id="reading-data">Reading Data</h2>
<p>Before getting too much further, though, I'm going to go through a bit about how yt thinks about &ldquo;chunking&rdquo; data.</p>
<p>The fundamental thing that yt does is <em>index</em> data.  (Well, that, and take a while to compile all the Cython code.)  Processing of the data is all layered on top of that &ndash; including some pretty cool semantics-of-data and units, visualization, etc.  The main thing is that if you do a subset, it knows where to go to grab that subset of data, and if you want to do something that touches everything, it'll do its best to reduce the number of times data is loaded off disk in service of that.</p>
<p>We do this with a &ldquo;<a href="https://ytep.readthedocs.io/en/latest/YTEPs/YTEP-0001.html">chunking</a>&rdquo; system, which is implemented differently if your data is discrete (i.e., particles), mesh-based, and so on.</p>
<p>So to show what the problem is, I'm going to load up a dataset from the <a href="https://fire.northwestern.edu/about-fire/">FIRE</a> project.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> yt
ds <span style="color:#f92672">=</span> yt<span style="color:#f92672">.</span>load(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">data/FIRE_M12i_ref11/snapshot_600.hdf5</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><pre><code>yt : [INFO     ] 2019-06-02 16:02:22,303 Calculating time from 1.000e+00 to be 4.355e+17 seconds
yt : [INFO     ] 2019-06-02 16:02:22,304 Assuming length units are in kpc/h (comoving)
yt : [INFO     ] 2019-06-02 16:02:22,337 Parameters: current_time              = 4.3545571088051386e+17 s
yt : [INFO     ] 2019-06-02 16:02:22,338 Parameters: domain_dimensions         = [1 1 1]
yt : [INFO     ] 2019-06-02 16:02:22,339 Parameters: domain_left_edge          = [0. 0. 0.]
yt : [INFO     ] 2019-06-02 16:02:22,341 Parameters: domain_right_edge         = [60000. 60000. 60000.]
yt : [INFO     ] 2019-06-02 16:02:22,342 Parameters: cosmological_simulation   = 1
yt : [INFO     ] 2019-06-02 16:02:22,343 Parameters: current_redshift          = 0.0
yt : [INFO     ] 2019-06-02 16:02:22,344 Parameters: omega_lambda              = 0.728
yt : [INFO     ] 2019-06-02 16:02:22,344 Parameters: omega_matter              = 0.272
yt : [INFO     ] 2019-06-02 16:02:22,345 Parameters: omega_radiation           = 0.0
yt : [INFO     ] 2019-06-02 16:02:22,347 Parameters: hubble_constant           = 0.702
</code></pre>
<p>At this point yt has done a tiny little bit of reading of the data &ndash; just enough to figure out some of the metadata.  It hasn't indexed anything yet or read any of the actual data fields off of disk.</p>
<p>Now let's make a plot of the gas density, integrated over the <code>z</code> axis of the simulation.  Keep in mind that in doing this, it will have to read all the gas particles and smooth them onto a buffer.  The first time this gets run, an index is generated and then stored to disk.  More on that in a moment.</p>
<p>I'm going to use <code>ds.r[:]</code> here for &ldquo;dataset region, but the whole thing&rdquo; and then I call <code>integrate</code> on it and specify the field to integrate.  Then, I plot it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">p<span style="color:#f92672">=</span>ds<span style="color:#f92672">.</span>r[:]<span style="color:#f92672">.</span>integrate(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">density</span><span style="color:#e6db74">&#34;</span>, axis<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">z</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>plot((<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">gas</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">density</span><span style="color:#e6db74">&#34;</span>))
</code></pre></div><pre><code>yt : [INFO     ] 2019-06-02 16:02:22,484 Allocating for 4.787e+06 particles
Loading particle index: 100%|██████████| 10/10 [00:00&lt;00:00, 817.25it/s]
yt : [INFO     ] 2019-06-02 16:02:23,623 xlim = 0.000000 60000.000000
yt : [INFO     ] 2019-06-02 16:02:23,623 ylim = 0.000000 60000.000000
yt : [INFO     ] 2019-06-02 16:02:23,633 Making a fixed resolution buffer of (('gas', 'density')) 800 by 800
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>(All that empty space is because there are only gas particles in the middle of the dataset!)</p>
<p>The first time any data needs to be read from a particle dataset, yt will construct an in-memory index of the data on disk; by default, it will store this in a sidecar file, so the next time that the dataset is read it does not need to be generated again.</p>
<p>The way the bitmap indices work is really fun, but that deserves its own blog post.  It suffices to say that the indexing helps to figure out both which <em>files</em> to read, and which <em>subsets</em> of those files to read, since we don't assume that the particles are sorted in any way.  (Mostly because each code tends to sort the particles in its own way!)</p>
<p>Now, for projecting over the whole domain, it's not that big a deal to read everything, since we have to anyway, but if we did a subset it could dramatically reduce the IO necessary, and it also keeps much less data resident in memory than the old implementation.</p>
<p>Continuing on, let's say that we now want to center at a different location.  We'd figure out the most dense point, and then set our center.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">c <span style="color:#f92672">=</span> ds<span style="color:#f92672">.</span>r[:]<span style="color:#f92672">.</span>argmax((<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">gas</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">density</span><span style="color:#e6db74">&#34;</span>))
</code></pre></div><p>(One thing this next set of code highlights is that, in general, how we handle centers in yt is a bit clumsy at times.  Writing this blog post led me to <a href="https://github.com/yt-project/yt/issues/2268">filing an issue</a> which may or may not get any traction or support.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">p<span style="color:#f92672">.</span>set_origin(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">center-window</span><span style="color:#e6db74">&#34;</span>)
p<span style="color:#f92672">.</span>set_center((c[<span style="color:#ae81ff">0</span>], c[<span style="color:#ae81ff">1</span>]))
p<span style="color:#f92672">.</span>zoom(<span style="color:#ae81ff">25</span>)
p<span style="color:#f92672">.</span>set_zlim((<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">gas</span><span style="color:#e6db74">&#34;</span>,<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">density</span><span style="color:#e6db74">&#34;</span>), <span style="color:#ae81ff">1e-6</span>, <span style="color:#ae81ff">1e-3</span>)
</code></pre></div><pre><code>yt : [INFO     ] 2019-06-02 16:02:25,607 xlim = -713.911179 59286.088821
yt : [INFO     ] 2019-06-02 16:02:25,611 ylim = 1049.283652 61049.283652
yt : [INFO     ] 2019-06-02 16:02:25,619 Making a fixed resolution buffer of (('gas', 'density')) 800 by 800
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>So, we can visualize now, and it's faster than it was before, and we also get much better results.  Great.  So why am I belaboring this point?</p>
<p>It's because in the background, yt is queryin a data object to see which items to read off disk, then it is reading those items off disk.  In this particular instance, it is doing what we call &ldquo;io&rdquo; chunking &ndash; this means to use whatever type of hinting is best to get the most efficient ordering it knows how.  Among other things, yt will try to minimize the number of times it opens a file, it seeks in a file, and it tries to keep the memory allocation count as low as possible.<br>
(I'll write more on this last point later &ndash; much of what yt does to index in yt-3.x and yt-4.0 is designed to keep the number of allocated arrays in the IO routines as low as possible, and to avoid any expensive concatenation or subselection operations.  It turns out, this is &hellip; not as big a deal as thought when this was made a design principle.  And in general, it leads to a lot more floating point operations than we would like, and sometimes more stuff in memory, too.)</p>
<h2 id="and-so-uh-chunking-is">And, so, uh, &ldquo;chunking&rdquo; is&hellip;?</h2>
<p>We can figure out how yt chunks this data by, well, asking it to do it manually!  Every data object presents a <code>chunks</code> interface which is a generator that modifies its internal state and then yields itself.  For instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dd <span style="color:#f92672">=</span> ds<span style="color:#f92672">.</span>all_data()
<span style="color:#66d9ef">for</span> chunk <span style="color:#f92672">in</span> dd<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>):
    <span style="color:#66d9ef">print</span>(chunk[<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">particle_ones</span><span style="color:#e6db74">&#34;</span>]<span style="color:#f92672">.</span>size)
</code></pre></div><pre><code>1048576
885527
753678
524288
317696
262144
262144
262144
262144
208609
</code></pre>
<p>I mentioned that this generator yields itself; this is true.  But the internal state is modified to store where we are in the iteration, along with things like the parameters for derived fields and the like.  The source for this looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> yt.data_objects.data_containers <span style="color:#f92672">import</span> YTSelectionContainer
YTSelectionContainer<span style="color:#f92672">.</span>chunks<span style="color:#960050;background-color:#1e0010">?</span><span style="color:#960050;background-color:#1e0010">?</span>
</code></pre></div><pre><code>Signature: YTSelectionContainer.chunks(self, fields, chunking_style, **kwargs)
Docstring: &lt;no docstring&gt;
Source:   
    def chunks(self, fields, chunking_style, **kwargs):
        # This is an iterator that will yield the necessary chunks.
        self.get_data() # Ensure we have built ourselves
        if fields is None: fields = []
        # chunk_ind can be supplied in the keyword arguments.  If it's a
        # scalar, that'll be the only chunk that gets returned; if it's a list,
        # those are the ones that will be.
        chunk_ind = kwargs.pop(&quot;chunk_ind&quot;, None)
        if chunk_ind is not None:
            chunk_ind = ensure_list(chunk_ind)
        for ci, chunk in enumerate(self.index._chunk(self, chunking_style,
                                   **kwargs)):
            if chunk_ind is not None and ci not in chunk_ind:
                continue
            with self._chunked_read(chunk):
                self.get_data(fields)
                # NOTE: we yield before releasing the context
                yield self
File:      ~/yt/yt/yt/data_objects/data_containers.py
Type:      function
</code></pre>
<p>Note that this relies on the <code>index</code> object providing the <code>_chunk</code> routine, which interprets the type of chunking.  Also, <code>_chunked_read</code> is a <a href="https://en.wikibooks.org/wiki/Python_Programming/Context_Managers">context manager</a> which looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">YTSelectionContainer<span style="color:#f92672">.</span>_chunked_read<span style="color:#960050;background-color:#1e0010">?</span><span style="color:#960050;background-color:#1e0010">?</span>
</code></pre></div><pre><code>Signature: YTSelectionContainer._chunked_read(self, chunk)
Docstring: &lt;no docstring&gt;
Source:   
    @contextmanager
    def _chunked_read(self, chunk):
        # There are several items that need to be swapped out
        # field_data, size, shape
        obj_field_data = []
        if hasattr(chunk, 'objs'):
            for obj in chunk.objs:
                obj_field_data.append(obj.field_data)
                obj.field_data = YTFieldData()
        old_field_data, self.field_data = self.field_data, YTFieldData()
        old_chunk, self._current_chunk = self._current_chunk, chunk
        old_locked, self._locked = self._locked, False
        yield
        self.field_data = old_field_data
        self._current_chunk = old_chunk
        self._locked = old_locked
        if hasattr(chunk, 'objs'):
            for obj in chunk.objs:
                obj.field_data = obj_field_data.pop(0)
File:      ~/yt/yt/yt/data_objects/data_containers.py
Type:      function
</code></pre>
<p>This is a bit clunky, but it stores the <em>old</em> state (because, believe it or not, sometimes we have multiple levels of chunking simultaneously, especially for things like spatial derivatives) and then it makes a fresh state, and then it resets it after the context manager concludes.</p>
<p>So the end result here is that we have a mechanism that divides the dataset up into the chunks it needs (<code>YTDataChunk</code> objects), and then iterates over them.  What does this look like for our particle dataset?  Well, we can find out, evidently, by looking at the <code>_current_chunk</code> attribute on the object yielded by <code>chunks</code>.</p>
<p>I've changed what we print out here just a little bit, because I want to keep the output a bit more human readable, but this is what it looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dd <span style="color:#f92672">=</span> ds<span style="color:#f92672">.</span>all_data()
<span style="color:#66d9ef">for</span> chunk <span style="color:#f92672">in</span> dd<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Examining chunk...</span><span style="color:#e6db74">&#34;</span>)
    <span style="color:#66d9ef">for</span> obj <span style="color:#f92672">in</span> chunk<span style="color:#f92672">.</span>_current_chunk<span style="color:#f92672">.</span>objs:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">    Examining obj...</span><span style="color:#e6db74">&#34;</span>,)
        <span style="color:#66d9ef">for</span> data_file <span style="color:#f92672">in</span> obj<span style="color:#f92672">.</span>data_files:
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">        {}: {}-{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(data_file<span style="color:#f92672">.</span>filename, data_file<span style="color:#f92672">.</span>start, data_file<span style="color:#f92672">.</span>end))
</code></pre></div><pre><code>Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 0-262144

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 262144-524288

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 524288-786432

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 786432-1048576

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 1048576-1310720

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 1310720-1572864

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 1572864-1835008

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 1835008-2097152

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 2097152-2359296

Examining chunk...
    Examining obj...
        /home/matthewturk/data/FIRE_M12i_ref11/snapshot_600.hdf5: 2359296-2567905
</code></pre>
<p>A few notes here.  Each chunk is able to have multiple &ldquo;objects&rdquo; associated with it (which in grid frontends usually means multiple grid objects) but here, we have only one entry in the <code>obj</code> list associated with each.  Each <code>obj</code> then only has one item in <code>data_files</code>, which is not <em>really</em> a data file, but instead a <em>subset</em> of a data file specified by its start and end indices.</p>
<p>If you're thinking this is a bit clumsy, I would agree with you.</p>
<h2 id="dask-stuff">Dask Stuff</h2>
<p>The issue that I wrote about at the start of this blog post shows up when we start looking at how these chunks are generated.  In principle, this does not map <em>that</em> badly to how dask expect chunks to be emitted.</p>
<p>(At this point I need to admit that while I've worked with dask, it's entirely possible that I am going to misrepresent its capabilities.  Any errors are my own, and if I find out I am mistaken about any of this, I will happily update this blog post!)</p>
<p>It's possible to create a dask array through the <code>dask.array.Array</code> constructor; this is described <a href="http://docs.dask.org/en/latest/array-design.html">in the array design docs</a>.  Since yt uses <a href="https://unyt.readthedocs.io">unyt</a> for attaching units we will need to do some additional work, but let's imagine that we are simply happy dealing with unit-less (and, I suppose, <code>unyt</code>-less) arrays for now.</p>
<p>To generate these arrays most efficiently, we need to be able to specify their <em>size</em>, how to <em>obtain</em> them, and maybe a couple other things.  But for our purposes, those are the two most important things.</p>
<p>Unfortunately, as you might be able to tell, this is not information that is super easily exposed <em>without iterating over the dataset</em>.  Sure, if we iterated and read everything, of course we can show the appropriate info. And, I posted a little bit about how one might do this on <a href="https://github.com/yt-project/yt/issues/1891">issue 1891</a>, but there's a key thing going on in that code &ndash; yt has already read all the data from disk.</p>
<p>So, this isn't ideal.</p>
<h2 id="chunks-are-not-persistent">Chunks are not persistent</h2>
<p>This all comes about because chunks are not <em>persistent</em>, and more specifically, chunks are always create <em>on-demand</em>.  Each different data object will have its own set of chunks, and these will map differently.  So, for instance, we might end up selecting all the same sets of objects, but they will have different sizes (and even each different field might be a different size).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">sp1 <span style="color:#f92672">=</span> ds<span style="color:#f92672">.</span>sphere(c, (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>))
sp2 <span style="color:#f92672">=</span> ds<span style="color:#f92672">.</span>r[ (<span style="color:#ae81ff">20.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>) : (<span style="color:#ae81ff">40.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>),
            (<span style="color:#ae81ff">25.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>) : (<span style="color:#ae81ff">45.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>),
            (<span style="color:#ae81ff">55.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>) : (<span style="color:#ae81ff">65.0</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Mpc</span><span style="color:#e6db74">&#34;</span>) ]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sp1 len == {}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">sp2 len == {}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(
    len(list(sp1<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>))),
    len(list(sp2<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>)))
))


<span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sp1 =&gt; </span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>join(str(chunk[<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">particle_ones</span><span style="color:#e6db74">&#34;</span>]<span style="color:#f92672">.</span>size) <span style="color:#66d9ef">for</span> chunk <span style="color:#f92672">in</span> sp1<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>)))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sp2 =&gt; </span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>join(str(chunk[<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">particle_ones</span><span style="color:#e6db74">&#34;</span>]<span style="color:#f92672">.</span>size) <span style="color:#66d9ef">for</span> chunk <span style="color:#f92672">in</span> sp2<span style="color:#f92672">.</span>chunks([], <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">io</span><span style="color:#e6db74">&#34;</span>)))
</code></pre></div><pre><code>sp1 len == 10
sp2 len == 10
sp1 =&gt;  388571 306586 341808 205880 50260 2 1 2 3 0
sp2 =&gt;  12 3673 480 29 146 200 77 419 3697 400
</code></pre>
<p>The trickiest part of this is that in these cases, we <em>don't</em> know how big each one is going to be!  For other types of indexing, it's slightly different &ndash; the indexing system for grids and octrees and meshes can figure out in advance (without reading data from disk) the precise number of values that will be read.  But for particles we don't necessarily know.</p>
<p>Unfortunately, even if we did, the way that the <code>YTDataChunk</code> objects are the result of creating, then <code>yield</code>-ing, rather than returning a list of objects with known sizes makes it harder to expose this to dask.  In particular, because we can't (inexpensively) fast-forward the generator or rewind it or even access it elementwise makes it tricky to interface.  One can expose unknown chunk sizes to dask, but it seems like we <em>could</em> do better.</p>
<h2 id="so-what-can-be-done">So what can be done?</h2>
<p>Well, let me first note that a lot of this is a result of trying to be clever!  Back when the chunking system was being implemented, it seemed like simple generator expressions were the right way to do it.  And, a bunch of layers have been added on top of those generator expressions that make it harder to simply strip that component out.</p>
<p>But recently, Britton Smith and I have been digging into some of the particle frontends, and we think we might have a solution that would both simplify a lot of this logic <em>and</em> make it a lot easier to expose the arrays to different array backends &ndash; specifically dask.</p>
<p>For more on that, wait for part two!</p>

    </div>

    



    
      

      
      
    

    

    


  </div>
</article>

<div class="container">
  <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

</div>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
        
      

      
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.ee93f50e7bcdd181a29c10939fba4467.js"></script>

  </body>
</html>

